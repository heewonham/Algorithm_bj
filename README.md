# Algorithm_bj
🔥 백준 알고리즘 문제풀이



테스트 케이스 만드는 방법 :

 `preopen("res/B3055.in","r",stdin);`

`B3055.in`

## # 3425 고스택

1. 입력 처리하는 부분
   명령어 문자 - 명령어에 따라 분기
   NUM 뒤에 숫자가 들어옴
   cpp같은 경우 문자열로 읽게 되면 숫자도 더 읽어야함.
   분기해서 적절한 명령어를 수행해야함
  2. 스택 구현

    직접 구현 혹은 자료구조 사용 
    cpp vector , array - 가장 끝에서 값을 추가 , 제거 등등 

    3. 명령어를 구현하는 부분 ... 총 10개 정도 

    뭔가 pop할때 없거나 나누기 할때 0이거나 
    값이 너무 크거나 10^9 
    변수 타입은 long으로 써야함. 그리고 예외사항 찾아보기 

    4. 초기화 
    5. 어려운 점 : 
       1. 예외처리
       2. 초기화 안되는 것
       3. 디버깅 



### # 2842 집배원 한상덕

* 우체국은 하나밖에 없다.
* 상덕이는 수평, 수직, 대각선 이동가능
* 가장 작은 고도와 가장 높은 고도의 사이 피로도 가장 낮은??



<< 포인트 >>

고도를 가장 낮은 순에서 높은 순으로 정렬한다.

고도를 하나씩 높여가면서 모두 갈 수 있는 높은 고도를 찾는다.

그 고도를 찾으면 낮은 고도를 하나씩 높이고 찾아간다.

--- > 결론 방식은 two pointer 방식임



### # 7453 합이 0인 네 정수

* A[a], B[b], C[c], D[d]의 합이 0인 a, b, c, d 번째의 쌍의 개수를 구하는 것
* 배열의 크기는 4000까지 이므로 총 개수는 4000 * 4 = 16000
* 또한 배열 안의 정수값의 절대값은 2^-28 ~ 2^28 = 268,435,456
* 그러므로 long으로 처리하자 (혹시모르니)



<< 포인트 >>

우선 a,b와 c,d의 합으로 나누고, 정렬한다.

그리고 투포인터 방식으로 a,b의 마이너스와 cd의 값을 비교하여 

cd가 더 크면 , cd을 줄이고 , cd와 ab가 같으면 count를 올려주고, 

ab가 더 크면 ab를 줄이고 합의 개수를 구한다.

 

### # 11050 ~ 11051 이항계수 1, 2

* 일일히 수열과 팩토리얼로 계산
* DP를 활용하여 처리



### # 1010 다리놓기

* N, M개의 사이트가 있음. M은 N가 같거나 크다.
* 다리끼리는 서로 겹쳐질 수 없음
* 경우의 수 구하기



<포인트>

* 이항계수 2와 완전 동일
* DP로 해결한다.



### # 3020 개똥벌레 (range update pointer query)

<포인트>

높이를 기준으로 구간마다 + - 1 처리를 한다.

예를들면, 종유석의 경우는 hit[1] += 1, hit[입력높이+1] -= 1 하고

석순은 hit[총높이 - 입력높이 + 1] += 1 처리를 한다.

후에 for문으로 그동안 계산한 값을 더하면서 최소값과 구간의 수를 구한다.



## 세그먼트 트리와 인덱스트리의 구분

세그먼트 트리 - lazy propagation 

인덱스 트리 - 완전트리? 느낌 



## 세그먼트 트리

`// 찾기` 

`int seg(int node, int s, int e, int l, int r){`

​	`// 범위를 벗어난 경우`

​	`if( r  < s  || e < l) return ;`

​	`// 범위 이내인 경우`

​	`if( l <= s && e <= r) return node;`

​	`// 범위를 살짝 초과한 경우 - 다시 질문가능`

​	`else{`

​		`return seg(node * 2, s, (s+e) / 2 , l , r) + seg(node * 2 + 1 , (s+e ) / 2 +1, e, l , r);`

​	`}`

`}`



`// update`

`void update(int node, int s, int e, int idx, int val){`

​	`if(idx < s || e < idx ) return ;`

​	`if (s == e ) tr[node] = val;`

​	`else`{

​		`update(node * 2, s, (s+e)/2, idx, val);`

​		`update(node * 2 + 1 , (s+e)/2 + 1, e, idx, val);`

​		`tr[node] = tr[node * 2] + tr[node*2 + 1];`

​	`}`

`}`



## 인덱스 트리

`// update`

`void update(int num, int val){`

​	`num += PIV`

​	`tree[num] = val;`

​	`n /= 2;`

​	`while(n){`

​		`tree[n] = tree[n*2] + tree[n*2+1]`

​		`n /= 2;`

​	`}`

`}`

`int query(int l, int r){`

​	`l += PIV; r += PIV;`

​	`int ret = 0;`

​	`while(l <= r){`

​		`(l%2 == 1) ret += tree[l++];`

​		`(r%2 == 0) ret += tree[r--];`

​		`l /=2, r /= 2;`		

​	`}`

​	`return ret;`

`}`



## # 1572 중앙값

* 세그먼트 트리 문제를 풀 때, 어느 것을 리프노드의 범위로 정할 것인지가 중요하다.
* 중앙값의 경우는 순위를 구하는 것처럼(사탕문제) 5개 중 중앙값은 3번째이기 때문에 리프노드를 총 입력 수인 N이 아니라 범위인 0~65536으로 처리했다.
* 또한 순서대로의 k번째 수열에서 중앙값을 정하는 것이기 때문에 k값이 차면 중앙값을 넣고 처음 넣었던 값을 빼고.. 이런 식으로 합을 더했다.
* 중요한 것은 입력 범위를 꼭 확인할 것!! 0이 포함되는 것을 확인하지 못해서 헤맸음



## # 2449 전구 - DP

* dp 문제는 전 범위의 가장 적은 변경 수를 저장하고 그 수를 점점 갱신한다.
* s ~ i 번째 범위 + (i+1) ~ e의 범위 그리고 s와 e의 색이 다르면 +1 
* 여기서 어디와 어디의 색을 비교할 것인가의 문제가 남는다.
* 동일하게 정한다.
  * 즉, s이면 i+1 왼쪽으로 맞추고
  * e이면 i로 맞춘다. 



## # 1520 내리막길 - DFS + DP

* 갈 수 있는 모든 길 탐색하는 문제이다.
* 갔던 곳 또 들렸다가 갈 수 있음. 즉, 경로만 완전 같지 않으면 한 개의 경로로 인정이된다. 
* 모든 범위를 탐색하는 것이기 때문에 BFS 보다 DFS로 풀어야 함. 목적지에 도달하면 DP +1로 기록한다.
* 그러면 **한번 갔던 곳**은 **기록했던 DP 배열**의 값을 반환하여 한번더 처리하지 않아도 된다. 



